#pragma once
#include <bitset>
#include "Exceptions/Exceptions.hpp"
#include <iomanip>
#include <bitset>
#include <map>
#include <chrono>
#include <iostream>
#include <fstream>
#include <string>
#include <cstdint>
#include <vector>


class Bitstream {
public:
Bitstream(std::vector<uint32_t> data);

void Add(Bitstream stream) {m_bitstreamData.insert(m_bitstreamData.end(), stream.GetDataVector().begin(), stream.GetDataVector().end()); }
void FillData(std::vector<uint32_t> data){ m_bitstreamData = data;}
void RemoveBits(unsigned int n);
uint32_t GetWord32() {return m_currentBuffer;}
std::vector<uint32_t> GetDataVector() {return m_bitstreamData;}
bool BitsAvailable() {return (m_bitsAvailable > 0);}
unsigned int NBitsAvailable() {return m_bitsAvailable;}
unsigned int AvailableWords() {return m_bitstreamData.size();}

private:
uint32_t m_currentBuffer;
std::vector<uint32_t> m_bitstreamData;
unsigned int m_bitsUsedOfNextWord;
long m_bitsAvailable;

const unsigned int m_usedBitsPerWord = 24;
};


class DecodeClass{
  public:
    void DecodeModuleData(std::map< std::pair<uint8_t, uint8_t>, std::vector<uint32_t> > dataMap)
  {
    bool praeambleFound = false;
    for(int module=0;module<8;module++){
      for(int LED=0;LED<2;LED++){
        std::pair<uint8_t, uint8_t> ModuleSide { module, LED };
        Bitstream bitstream(dataMap[ModuleSide]); //something with moduleData[module] in ()
      }
    }
    
  
  int removedBits = 0;
  auto time_start = std::chrono::high_resolution_clock::now();
  auto time_end = std::chrono::high_resolution_clock::now();
  long int eventCount = 0;

  

    return;
  }
  SCTEvent* GetModule(unsigned int moduleID){}
  const SCTEvent& GetModule(uint32_t moduleID) const;
  
  private:
  void AddModule(unsigned int moduleID, SCTEvent *event){}
};

void AddHit (unsigned int chip, unsigned int strip, unsigned int pattern, int chipID)
//what is chipIDMap
//where is m_Hits
{/*
  std::vector < std::vector < std::pair<uint8_t, uint8_t> > > m_Hits;
  chip |= 0x20; // adding 2 MSB for chip address. All chips are served by "primary fiber".
  auto it = m_chipIDMap.find(chip); //fix this
  if (it == m_chipIDMap.end()) { //fix this when i know what chipIDmap is
    if (false){
      std::cout << "ERROR: AddHit(): passed chipID is not known! chipID = 0x"<<std::hex<<chip<<std::endl;
      std::cout << "Known IDs: "<<std::endl;
      for (auto it : m_chipIDMap){
        std::cout << " ChipID = 0x"<<std::hex<<it.first<<" Index = "<<std::dec<<it.second<<std::endl;
        m_Hits.back().push_back(std::make_pair(chip, strip));
      }
    }
    return;
  }
  m_Hits[it->second].push_back(std::make_pair(strip, pattern));
  */
}

class SCTEvent {
  public:
    SCTEvent (unsigned int moduleID, unsigned int l1id, unsigned int bcid);
    ~SCTEvent();
    
    void AddHeader(unsigned int l1id, unsigned int bcid);
    void AddHit (unsigned int chip, unsigned int strip, unsigned int pattern);
    void AddError (unsigned int chip, unsigned int err);
    void AddUnknownChip (unsigned int chip) {m_UnkownChips.push_back(chip);}
    
    unsigned int GetNHits();
    unsigned int GetNHits(int chip);
    std::vector < std::vector < std::pair<uint8_t, uint8_t> > > GetHits() {return m_Hits;}
    std::vector < std::pair<uint8_t, uint8_t> >                 GetHits(int chip);
    std::vector < std::vector < uint8_t > >                     GetErrors() {return m_Errors;}
    std::vector < uint8_t >                                     GetErrors(int chip);
    std::vector < uint8_t >                                     GetUnknownChips() {return m_UnkownChips;}
    
    bool HasError() {return m_hasError;}
    bool IsComplete() {return m_complete;}
    void SetComplete() {m_complete = true;}
    bool MissingData() {return m_missingData;}
    void SetMissingData() {m_missingData = true;}
    bool BCIDMismatch() {return m_bcidMismatch;}
    void SetBCIDMismatch() {m_bcidMismatch = true;}
    unsigned short GetL1ID() {return m_l1id;}
    unsigned short GetBCID() {return m_bcid;}
    
  private:
    std::vector < std::vector < std::pair<uint8_t, uint8_t> > > m_Hits; // chips[12][nHits] , hit = pair {Strip Nr, Hit pattern}
    std::vector < std::vector < uint8_t > > m_Errors; // chips[12][error]
    std::vector < uint8_t > m_UnkownChips; // chipIDs that were not expected
    unsigned short m_moduleID;
    unsigned short m_bcid;
    unsigned short m_l1id;
   
    bool m_complete; // sepcifies if data from all chips (i.e. LED and LEDX lines is inserted
    bool m_missingData; // sepcifies if data from all chips (i.e. LED and LEDX lines is inserted
    bool m_bcidMismatch; // bcid mismatch between led and ledX data streams
    bool m_hasError; // bcid mismatch between led and ledX data streams
    std::map<unsigned int, unsigned int> m_chipIDMap; // maps chipID to vector index
  };


/** \brief Support class providing a contineous bitstream, used to analyse SCT module data.
The input vector is expected to contain the module data in the 24 LSB of the 32 bit words,
as received from the tracker readout board. Bitstream data is stringed together and available in
junks of 32-bits using Get32BitWord(). RemoveBits(n) will remvove the n MSB from the bitstream.
Next call to Get32BitWord() will have the reamining bitstream aligned properly at the MSB of the
word.
*/



