
#pragma region TrackerDataFragment

bool TrackerDataFragment::m_debug = false;
//
// Constructor
//
inline TrackerDataFragment::TrackerDataFragment(const uint32_t *data, size_t size)
{
    m_size = size;
    event.m_event_id = 0xffffff;
    event.m_bc_id = 0xffff;

    // now to fill data members from data - can refer to TRBEvent in gpiodrivers.
    // const uint32_t errorMask   = 0x0000000F; //  4 bits
    const uint32_t bcidMask    = 0x00000FFF; // 12 bits
    const uint32_t payloadMask = 0x00FFFFFF; // 24 bits

    for (size_t i=0; i<size/4;i++ )
    {
       int frameType = (data[i] & 0x3<<30)>>30;//(d & 0b11<<30)>>30;
      //  int frameCounter=(data[i] & 0x7<<27)>>27;
       int moduleOrInfo=(data[i] & 0x7<<24)>>24;
       int modNer=0; //mod ID in error message
       int errId=(data[i]&0xF);
       
      // std::cout<<frameType<<" | "<<frameCounter<<std::endl;
       if (frameType==0 and moduleOrInfo==0){event.m_event_id=data[i]&payloadMask;}
       if (frameType==1)
       { 
         switch(moduleOrInfo)
         {
           case 0:event.m_bc_id=data[i]&bcidMask; break;
           case 1:        
                  std::cout<<"TRB ERROR: "<<errId<<std::endl; 
                  event.m_trb_error_id=errId;
                  break;
           case 2:
           case 3:
                  modNer=(data[i]&0x7<<24)>>24;
                  event.m_module_error_ids.push_back((frameType%2)<<7 | (modNer) << 4 | errId);
                  std::cout<<"LED(x) Module error: Module "<<modNer<<" ErrID: "<<errId<<std::endl; break;
         }
       }
       
       if (frameType == 2 || frameType == 3)
	     {
	      std::pair<uint8_t, uint8_t> key { moduleOrInfo , (frameType == 2 ? 0 : 1) };
	      event.m_modDB[key].push_back(data[i] & payloadMask);
	     }       
    }
  
  DecodeModuleData(event.m_modDB);

}
  
inline void TrackerDataFragment::DecodeModuleData(std::map< std::pair<uint8_t, uint8_t>, std::vector<uint32_t> > dataMap)
{
  std::cout << "DecodeModuleData debug = " << m_debug << std::endl;
  for (uint8_t module = 0; module < MODULES_PER_FRAGMENT; module++)
  {
    for (uint8_t LED = 0; LED < SIDES_PER_MODULE; LED++)
    {
      if (m_debug) std::cout << "Decoding data for (" << static_cast<uint32_t>(module) << "," << static_cast<uint32_t>(LED) << ")." << std::endl;
      SCTEvent* sctEvent {nullptr};

      bool praeambleFound = false;
      std::pair<uint8_t, uint8_t> ModuleSide { module, LED };
      Bitstream bitstream(dataMap[ModuleSide]); //something with moduleData[module] in ()
      int removedBits = 0;

      // auto time_start = std::chrono::high_resolution_clock::now();
      // auto time_end = std::chrono::high_resolution_clock::now();
      // long int eventCount = 0;
      while (bitstream.BitsAvailable())
      {
        if (m_debug) std::cout << "Data word = "<<std::hex << bitstream.GetWord32() <<std::endl;
        if ((bitstream.GetWord32() & MASK_MODULE_HEADER) == TAG_MODULE_HEADER){
          // eventCount++;
          // if (eventCount %5000 == 0 ){ 
          //   time_end = std::chrono::high_resolution_clock::now();
          //   auto duration = std::chrono::duration_cast<std::chrono::microseconds>(time_end-time_start);
          //   std::cout << "Decoding module data for evnt: "<<eventCount<< " rate = "<<5.0e6/duration.count()<<" kHz"<<std::endl;
          //   time_start = std::chrono::high_resolution_clock::now();
          // }
          unsigned int l1id = ((bitstream.GetWord32() >> RSHIFT_MODULE_L1ID)&MASK_MODULE_L1ID);
          unsigned int bcid = ((bitstream.GetWord32() >> RSHIFT_MODULE_BCID)&MASK_MODULE_BCID);

          if (m_debug) std::cout << "Module Header: L1D = "<<std::dec<< l1id <<" BCID = "<< bcid << std::endl;
          if (m_debug) std::cout << "     removed bits bfore finding Module Header = "<<removedBits<<std::endl;

          if (LED==0)
          {
            // process first half of module data (led / ledx line)
            //if (m_Events.size() == 0){} // first event
            //trbEvent = new TRBEvent(l1id, bcid);
            sctEvent = new SCTEvent(module, l1id, bcid);
            // event.AddModule(sctEvent);
            event.SetModule(module, sctEvent);
            if (m_debug) std::cout << "Added SCTEvent data object for (" << static_cast<uint32_t>(module) << "," << static_cast<uint32_t>(LED) << ")." << std::endl;
            //trbEvent->AddModule(module, sctEvent);
            //m_Events.push_back(trbEvent);
          }
          else
          {
            sctEvent = event.GetModule(module);
            if (m_debug && (sctEvent != nullptr)) std::cout << "Found SCTEvent data object for (" << static_cast<uint32_t>(module) << "," << static_cast<uint32_t>(LED) << ")." << std::endl;
          }
          
          removedBits = 0;
          bitstream.RemoveBits(19);
          praeambleFound = true;
          continue;
        }
        if (praeambleFound && (sctEvent == nullptr))
        {
          if (m_debug) std::cout << "SCTEvent data object for (" << static_cast<uint32_t>(module) << "," << static_cast<uint32_t>(LED) << ") not found." << std::endl;
          praeambleFound = false;
        }
        if (!praeambleFound)
        {
          bitstream.RemoveBits(1);
          removedBits++;
          continue;
        }
        if ((bitstream.GetWord32() & MASK_MODULE_ERROR) == TAG_MODULE_ERROR && praeambleFound)
        {
          unsigned int chip = ((bitstream.GetWord32() >> RSHIFT_CHIPADD_ERR)&MASK_CHIPADD_ERR);
          unsigned int err = ((bitstream.GetWord32() >> RSHIFT_ERR)&MASK_ERR);
          if (m_debug) std::cout << "Module Data: ERROR code 0x"<<std::hex<< err << " for chip "<<std::dec<< chip <<std::endl;
          sctEvent->AddError(chip, err);
          bitstream.RemoveBits(11);
          continue;
        }
        if ((bitstream.GetWord32() & MASK_MODULE_CONFIG) == TAG_MODULE_CONFIG && praeambleFound)
        {
          bitstream.RemoveBits(28);
          continue;
        }
        if ((bitstream.GetWord32() & MASK_MODULE_DATA) == TAG_MODULE_DATA && praeambleFound)
        {
          unsigned int chip = ((bitstream.GetWord32() >> RSHIFT_CHIPADD_DATA)&MASK_CHIPADD_DATA);
          unsigned int channel = ((bitstream.GetWord32() >> RSHIFT_CHANNEL_DATA)&MASK_CHANNEL_DATA);
          bitstream.RemoveBits(13); // after that we expect n-times <1><xxx> => check MSB to be 1
          while ( ((bitstream.GetWord32() & 0x80000000) == 0x80000000) )
          {
            // data packet
            // !!! Trailer looks the same in this definition! => Always check if a trailer is found
            if ((bitstream.GetWord32() & MASK_MODULE_TRAILER) == TAG_MODULE_TRAILER){
            if (m_debug) std::cout << "Module Trailer "<< std::endl;
            bitstream.RemoveBits(16);
            praeambleFound = false;
            
            continue;
            }
            unsigned int hit = (bitstream.GetWord32() >> 28) & 0x7;
            sctEvent->AddHit(chip, channel, hit);
            if (m_debug) std::cout << "  Hit pattern = "<<hit<<std::endl;
            bitstream.RemoveBits(4);
          }
          continue;
        }
        if ((bitstream.GetWord32() & MASK_MODULE_NODATA) == TAG_MODULE_NODATA && praeambleFound) 
        {
          if (m_debug) std::cout << "  No Hit packet"<<std::endl;
          bitstream.RemoveBits(3);
          continue;
        }
        // data is only valid after a praeamble (aka header) was found. Otherwise praeamble might be mistaken as an error code
        praeambleFound = false;
        if (m_debug) std::cout << "WARNING: unable to decode bitstream. Removing 1 bit until alignment is found again."<<std::endl;
        bitstream.RemoveBits (1);          
      }
    }
  } 
  // auto time_start = std::chrono::high_resolution_clock::now();
  // auto time_end = std::chrono::high_resolution_clock::now();
  // long int eventCount = 0;
  return;
}

#pragma endregion TrackerDataFragment

#pragma region Bitstream
//
// Constructor
//
inline Bitstream::Bitstream(std::vector<uint32_t> data) : m_currentBuffer{0}, m_bitsUsedOfNextWord{0}, m_bitsAvailable{0}
{
  m_bitstreamData = data;
  
  if (m_bitstreamData.size() == 0){
    // std::cout << "WARNING: no data passed to Bitstrem class"<<std::endl;
    m_bitsAvailable = 0;
    return;
  }
  m_currentBuffer = (m_bitstreamData[0] << (32 - m_usedBitsPerWord)); // copy element 0 to buffer
  m_bitstreamData.erase(m_bitstreamData.begin()); // remove element 0
  m_bitsAvailable = (32 - m_usedBitsPerWord);
  // now we fill the remaining bits of the buffer
  if (m_bitsUsedOfNextWord > m_usedBitsPerWord) {
    std::cout << "FATAL: this case is not handeled!"<<std::endl;
    throw;
  }
  if (m_bitstreamData.size() == 0){ // no more data
    return;
  }
  m_bitsUsedOfNextWord = (32 - m_usedBitsPerWord);
  m_currentBuffer |= (m_bitstreamData[0] >> ( m_usedBitsPerWord-m_bitsUsedOfNextWord ));
  m_bitsAvailable = 32;
}

inline void Bitstream::RemoveBits(unsigned int n)
{
  m_currentBuffer <<= n;
  //std::cout <<"avilable words = " << m_bitstreamData.size()<<"  m_bitsAvailable = "<<std::dec<<m_bitsAvailable<<" bits used: "<<m_bitsUsedOfNextWord<<" removing "<<n<<" bits"<<std::endl;
  if (m_bitstreamData.size() == 0){
    m_bitsAvailable -= n;
    if (m_bitsAvailable < 0) m_bitsAvailable = 0;
    return;
  }
  //  now we have n free bits;
  uint32_t mask = 1;
  for (unsigned int i = 1; i < n; i++){
    mask <<= 1;
    mask |= 1;
  }
  
  if ((m_usedBitsPerWord - m_bitsUsedOfNextWord) >= n){ // still enough bits in m_bitstreamData[0] to use
    // std::cout <<"Enough usable bits in current word"<<std::endl;
    m_currentBuffer |= (m_bitstreamData[0] >> (m_usedBitsPerWord - (m_bitsUsedOfNextWord + n))) & mask;
    m_bitsUsedOfNextWord += n;
    if (m_bitsUsedOfNextWord == m_usedBitsPerWord){ // all bits of word used
      m_bitstreamData.erase(m_bitstreamData.begin());
      m_bitsUsedOfNextWord = 0;
    }
  } else { // need more bits than in next word available
    // std::cout <<"Not enough usable bits in current word. "<<std::endl;
    int missingBits = ( (m_bitsUsedOfNextWord + n) -m_usedBitsPerWord);
    // std::cout << "   Left shift of word by "<<std::dec<<missingBits<<std::endl;
    
    m_currentBuffer |= (m_bitstreamData[0] << ( missingBits)) & mask;
    m_bitstreamData.erase(m_bitstreamData.begin());
    m_bitsUsedOfNextWord = 0;
    if (m_bitstreamData.size() == 0){
      m_bitsAvailable -= n-(m_usedBitsPerWord-m_bitsUsedOfNextWord) ;
      if (m_bitsAvailable < 0) m_bitsAvailable = 0;
      return; // no more data
    }
    // still need to copy n-(m_usedBitsPerWord-m_bitsUsedOfNextWord) bits
    while ((int)(missingBits - m_usedBitsPerWord) > 0){
      // copy full word, aligned with last valid bit
      // std::cout << "   Left shift of word by "<<std::dec<<(missingBits - m_usedBitsPerWord)<<std::endl;
      m_currentBuffer |= (m_bitstreamData[0] << (missingBits - m_usedBitsPerWord) );
      missingBits -= m_usedBitsPerWord;
      m_bitstreamData.erase(m_bitstreamData.begin());
      m_bitsUsedOfNextWord = 0;
      if (m_bitstreamData.size() == 0){
        m_bitsAvailable -= n-(m_usedBitsPerWord-m_bitsUsedOfNextWord) ;
        if (m_bitsAvailable < 0) m_bitsAvailable = 0;
        return; // no more data
      }
    }
    // std::cout << "   Right shift of next word by "<<std::dec<<(m_usedBitsPerWord - missingBits )<<std::endl;
    m_currentBuffer |= (m_bitstreamData[0] >> (m_usedBitsPerWord - missingBits ) );
    m_bitsUsedOfNextWord += (missingBits);
    
  }
}


#pragma endregion Bitstream

#pragma region TRBEvent

//
//  Destructor to delete allocated memory
//
inline TrackerDataFragment::TRBEvent::~TRBEvent()
{
  for (auto sctevt : m_hits_per_module)
  {
    if (sctevt != nullptr) delete sctevt;
  }
}

#pragma endregion TRBEvent

#pragma region SCTEvent

inline SCTEvent::SCTEvent (uint8_t moduleID, unsigned int l1id, unsigned int bcid) 
: m_moduleID(moduleID), m_bcid(bcid), m_l1id(l1id), m_complete(false), m_missingData(false), m_bcidMismatch(false), m_hasError(false)
{
  m_Hits.resize(13);
  m_Errors.resize(13);
  m_chipIDMap.insert(std::pair<unsigned int, unsigned int>(0x20, 0));
  m_chipIDMap.insert(std::pair<unsigned int, unsigned int>(0x21, 1));
  m_chipIDMap.insert(std::pair<unsigned int, unsigned int>(0x22, 2));
  m_chipIDMap.insert(std::pair<unsigned int, unsigned int>(0x23, 3));
  m_chipIDMap.insert(std::pair<unsigned int, unsigned int>(0x24, 4));
  m_chipIDMap.insert(std::pair<unsigned int, unsigned int>(0x25, 5));
  m_chipIDMap.insert(std::pair<unsigned int, unsigned int>(0x28, 6));
  m_chipIDMap.insert(std::pair<unsigned int, unsigned int>(0x29, 7));
  m_chipIDMap.insert(std::pair<unsigned int, unsigned int>(0x2a, 8));
  m_chipIDMap.insert(std::pair<unsigned int, unsigned int>(0x2b, 9));
  m_chipIDMap.insert(std::pair<unsigned int, unsigned int>(0x2c, 10));
  m_chipIDMap.insert(std::pair<unsigned int, unsigned int>(0x2d, 11));
}

/** \brief Add another header to  module. This happens of data from led and ledx lines are processed.
 *  Consistency checks on l1id and bcid are performed. If a bcid mismatch is detected BCIDMismatch()
 *  will return true afterwards. If an l1id mismatch is detected MissingData() will return true.
 *  Events are marked as complete if no mismatch is detected.
 */
inline void SCTEvent::AddHeader(unsigned int l1id, unsigned int bcid)
{
  if (m_l1id == l1id && m_bcid == bcid){
    this->SetComplete();
    return;
  }
  if (m_l1id != l1id){
    m_complete = false;
    m_missingData = true;
  }
  if (m_bcid != bcid){
    m_bcidMismatch = true;
  }
}

/** \brief Add error to module
 */
inline void SCTEvent::AddError (unsigned int chip, unsigned int err)
{
  chip |= 20; // Add const 2MSB of chip address
  m_hasError = true;
  auto it = m_chipIDMap.find(chip);
  if (it == m_chipIDMap.end()) {
    m_Errors.back().push_back(0xff);
    std::cout << "ERROR: AddError(): passed chipID is not known! chipID = 0x"<<std::hex<<chip<<std::endl;
    // std::cout << "Known IDs: "<<std::endl;
    return;
  }
  m_Errors[it->second].push_back(err);
}

/** \brief Add a hit to this module
 */
inline void SCTEvent::AddHit (unsigned int chip, unsigned int strip, unsigned int pattern)
{
  chip |= 0x20; // adding 2 MSB for chip address. All chips are served by "primary fiber".
  auto it = m_chipIDMap.find(chip);
  if (it == m_chipIDMap.end()) {
    if (false){
      std::cout << "ERROR: AddHit(): passed chipID is not known! chipID = 0x"<<std::hex<<chip<<std::endl;
      std::cout << "Known IDs: "<<std::endl;
      for (auto it : m_chipIDMap){
        std::cout << " ChipID = 0x"<<std::hex<<it.first<<" Index = "<<std::dec<<it.second<<std::endl;
        m_Hits.back().push_back(std::make_pair(chip, strip++));
      }
    }
    return;
  }
  m_Hits[it->second].push_back(std::make_pair(strip, pattern));
}

/** \brief returns number of hits found in this event in this module
 */
inline unsigned int SCTEvent::GetNHits() const
{
  unsigned int hits = 0;
  for (auto chip : m_Hits){
    hits += chip.size();
  }
  return hits;
}

/** \brief returns number of hits found in this event in the given chip
 */
inline unsigned int SCTEvent::GetNHits(int chip) const
{
  auto it = m_chipIDMap.find(chip);
  if (it == m_chipIDMap.end()) {
    if (chip == 0){
      return m_Hits.back().size(); // unknown chip occurences
    }
    std::cout << "ERROR: GetNHits(): passed chipID is not known! chipID = 0x"<<std::hex<<chip<<std::endl;
    throw;
  }
  return m_Hits[it->second].size();
}

/** \brief returns hits for the given chip
 */
inline std::vector < std::pair<uint8_t, uint8_t> > SCTEvent::GetHits(int chip) const
{
  auto it = m_chipIDMap.find(chip);
  if (it == m_chipIDMap.end()) {
    std::cout << "ERROR: GetHits(): passed chipID is not known! chipID = 0x"<<std::hex<<chip<<std::endl;
    throw;
  }
  return m_Hits[it->second];
}

/** \brief returns errors for the given chip
 */
inline std::vector < uint8_t > SCTEvent::GetErrors(int chip) const
{
  auto it = m_chipIDMap.find(chip);
  if (it == m_chipIDMap.end()) {
    std::cout << "ERROR: GetErrors(): passed chipID is not known! chipID = 0x"<<std::hex<<chip<<std::endl;
    throw;
  }
  return m_Errors[it->second];
}

#pragma endregion SCTEvent

// non-member function to dump TrackerDataFragment

inline std::ostream &operator<<(std::ostream &out, const TrackerDataFragment &event) 
{
  try {
    out
    <<std::setw(11)<<" event_id: "<<std::setfill(' ')<<std::setw(32)<<event.event_id()<<std::setfill(' ')<<std::endl
    <<std::setw(11)<<" bc_id: "<<std::setfill(' ')<<std::setw(32)<<event.bc_id()<<std::setfill(' ')<<std::endl;

    out<<"Undecoded data extracted for (module,side) pairs: ";
    for (auto entry : event.module_modDB())
    {
      out<<"(" << static_cast<uint32_t>(entry.first.first) << "," << static_cast<uint32_t>(entry.first.second) << ") ";
    }
    out<<std::endl;
    
    for (size_t module = 0; module < TrackerDataFragment::MODULES_PER_FRAGMENT; module++)
    {
      if (event.hasData(module))
      {
        auto sct = event[module];
        out << "Module " << module << " has strip data (" << sct.GetNHits() << " decoded hits from all chips)" << std::endl;
      }
    }

  } catch ( TrackerDataException& e ) {
    out<<e.what()<<std::endl;
    out<<"Corrupted data for Tracker data event "<<event.event_id()<<", bcid "<<event.bc_id()<<std::endl;
    out<<"Fragment size is "<<event.size()<<" bytes total"<<std::endl;
  }

 return out;
}
