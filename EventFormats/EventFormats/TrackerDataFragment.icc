#pragma once
#include <bitset>
#include "Exceptions/Exceptions.hpp"
#include <iomanip>
#include <bitset>
#include <map>
#include <chrono>
#include <iostream>
#include <fstream>
#include <string>
#include <cstdint>
#include <vector>


class Bitstream {
public:
Bitstream(std::vector<uint32_t> data);

void Add(Bitstream stream) {m_bitstreamData.insert(m_bitstreamData.end(), stream.GetDataVector().begin(), stream.GetDataVector().end()); }
void FillData(std::vector<uint32_t> data){ m_bitstreamData = data;}
void RemoveBits(unsigned int n);
uint32_t GetWord32() {return m_currentBuffer;}
std::vector<uint32_t> GetDataVector() {return m_bitstreamData;}
bool BitsAvailable() {return (m_bitsAvailable > 0);}
unsigned int NBitsAvailable() {return m_bitsAvailable;}
unsigned int AvailableWords() {return m_bitstreamData.size();}

private:
uint32_t m_currentBuffer;
std::vector<uint32_t> m_bitstreamData;
unsigned int m_bitsUsedOfNextWord;
long m_bitsAvailable;

const unsigned int m_usedBitsPerWord = 24;
};

struct TrackerDataFragment {
  #pragma region constants
    const uint32_t MASK_TRBFRAME            = 0xC7000000;
    const uint32_t TRB_HEADER               = 0x00000000;
    const uint32_t TRB_TRAILER              = 0x01000000;
    const uint32_t TRB_END                  = 0x07000eee;
    
    const uint32_t MASK_WORDTYPE            = 0xC0000000;
    const uint32_t WORDTYPE_TRBHEADER       = 0x0;
    const uint32_t WORDTYPE_TRBTRAILER      = 0x0;
    const uint32_t WORDTYPE_TRBDATA         = 0x40000000;
    const uint32_t WORDTYPE_MODULEDATA_LED  = 0x80000000;
    const uint32_t WORDTYPE_MODULEDATA_LEDX = 0xC0000000;
    
    const uint32_t MASK_TRBDATATYPE             = 0x7000000;
    static const uint32_t TRBDATATYPE_BCID             = 0x0000000;
    static const uint32_t TRBDATATYPE_TRBERROR         = 0x1000000;
    static const uint32_t TRBDATATYPE_MODULEERROR_LED  = 0x2000000;
    static const uint32_t TRBDATATYPE_MODULEERROR_LEDX = 0x3000000;
    
    const uint32_t MASK_FRAMECNT    = 0x38000000;
    const uint32_t RSHIFT_FRAMECNT  = 27;
    const uint32_t MASK_BCID     = 0xFFF;
    const uint32_t MASK_ERROR    = 0xF;
    const uint32_t MASK_MODULEDATA_MODULEID    = 0x7000000;
    const uint32_t RSHIFT_MODULEDATA_MODULEID  = 24;
    const uint32_t MASK_MODULEDATA = 0xFFFFFF;
    const uint32_t MASK_TRBDATA_MODULEID       = 0x0700000;
    const uint32_t SHIFT_TRBDATA_MODULEID       = 20;
    const uint32_t MASK_EVNTCNT  = 0xFFFFFF;
    const uint32_t MASK_CRC      = 0xFFFFFF;
    const uint32_t END_OF_DAQ    = 0x7000EEE; // magic word
    
    const unsigned int usefulBitsModuleData = 32 ; // How many bits are used per word? All MASK / TAG constants rely on this alignment
    // MASKS for module data
    
    const uint32_t MASK_MODULE_HEADER = 0xFC002000;
    const uint32_t TAG_MODULE_HEADER  = 0xE8002000;
    const uint32_t MASK_MODULE_TRAILER= 0xFFFF0000;
    const uint32_t TAG_MODULE_TRAILER = 0x80000000;
    const uint32_t MASK_MODULE_ERROR  = 0xE0200000;
    const uint32_t TAG_MODULE_ERROR   = 0x00200000;
    const uint32_t MASK_MODULE_CONFIG = 0xE1C02010;
    const uint32_t TAG_MODULE_CONFIG  = 0x1C02010;
    const uint32_t MASK_MODULE_DATA   = 0xC0040000;
    const uint32_t TAG_MODULE_DATA    = 0x40040000;
    const uint32_t MASK_MODULE_NODATA = 0xE0000000;
    const uint32_t TAG_MODULE_NODATA  = 0x20000000;
    
    // access data modules with bit shift & mask
    const uint32_t RSHIFT_MODULE_BCID = 14;
    const uint32_t MASK_MODULE_BCID   = 0xff;
    const uint32_t RSHIFT_MODULE_L1ID = 22;
    const uint32_t MASK_MODULE_L1ID   = 0xf;
    
    const uint32_t RSHIFT_CHIPADD_CONF = 25;
    const uint32_t MASK_CHIPADD_CONF   = 0xF;
    const uint32_t RSHIFT_CONF1        = 14;
    const uint32_t RSHIFT_CONF2        = 5;
    const uint32_t MASK_CONF           = 0xFF;
    const uint32_t RSHIFT_CHIPADD_ERR  = 25;
    const uint32_t MASK_CHIPADD_ERR    = 0xF;
    const uint32_t RSHIFT_ERR          = 22;
    const uint32_t MASK_ERR            = 0x7;
    const uint32_t RSHIFT_CHIPADD_DATA = 26;
    const uint32_t MASK_CHIPADD_DATA   = 0xF;
    const uint32_t RSHIFT_CHANNEL_DATA = 19;
    const uint32_t MASK_CHANNEL_DATA   = 0x7F;
#pragma endregion constants
  
  TrackerDataFragment( const uint32_t *data, size_t size ) {};

  class SCTEvent {
    public:
    private:
  };
  
  void DecodeModuleData(std::map< std::pair<uint8_t, uint8_t>, std::vector<uint32_t> > dataMap){};

  public:
  private:

};
