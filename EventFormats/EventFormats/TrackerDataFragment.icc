#pragma once
#include <bitset>
#include "Exceptions/Exceptions.hpp"
#include <iomanip>
#include <bitset>
#include <map>
#include <chrono>
#include <iostream>
#include <fstream>
#include <string>
#include <cstdint>
#include <vector>


class Bitstream {
public:
Bitstream(std::vector<uint32_t> data);

void Add(Bitstream stream) {m_bitstreamData.insert(m_bitstreamData.end(), stream.GetDataVector().begin(), stream.GetDataVector().end()); }
void FillData(std::vector<uint32_t> data){ m_bitstreamData = data;}
void RemoveBits(unsigned int n);
uint32_t GetWord32() {return m_currentBuffer;}
std::vector<uint32_t> GetDataVector() {return m_bitstreamData;}
bool BitsAvailable() {return (m_bitsAvailable > 0);}
unsigned int NBitsAvailable() {return m_bitsAvailable;}
unsigned int AvailableWords() {return m_bitstreamData.size();}

private:
uint32_t m_currentBuffer;
std::vector<uint32_t> m_bitstreamData;
unsigned int m_bitsUsedOfNextWord;
long m_bitsAvailable;

const unsigned int m_usedBitsPerWord = 24;
};

struct TrackerDataFragment { 
#pragma region constants
   const uint32_t MASK_TRBFRAME            = 0xC7000000;
    const uint32_t TRB_HEADER               = 0x00000000;
    const uint32_t TRB_TRAILER              = 0x01000000;
    const uint32_t TRB_END                  = 0x07000eee;
    
    const uint32_t MASK_WORDTYPE            = 0xC0000000;
    const uint32_t WORDTYPE_TRBHEADER       = 0x0;
    const uint32_t WORDTYPE_TRBTRAILER      = 0x0;
    const uint32_t WORDTYPE_TRBDATA         = 0x40000000;
    const uint32_t WORDTYPE_MODULEDATA_LED  = 0x80000000;
    const uint32_t WORDTYPE_MODULEDATA_LEDX = 0xC0000000;
    
    const uint32_t MASK_TRBDATATYPE             = 0x7000000;
    static const uint32_t TRBDATATYPE_BCID             = 0x0000000;
    static const uint32_t TRBDATATYPE_TRBERROR         = 0x1000000;
    static const uint32_t TRBDATATYPE_MODULEERROR_LED  = 0x2000000;
    static const uint32_t TRBDATATYPE_MODULEERROR_LEDX = 0x3000000;
    
    const uint32_t MASK_FRAMECNT    = 0x38000000;
    const uint32_t RSHIFT_FRAMECNT  = 27;
    const uint32_t MASK_BCID     = 0xFFF;
    const uint32_t MASK_ERROR    = 0xF;
    const uint32_t MASK_MODULEDATA_MODULEID    = 0x7000000;
    const uint32_t RSHIFT_MODULEDATA_MODULEID  = 24;
    const uint32_t MASK_MODULEDATA = 0xFFFFFF;
    const uint32_t MASK_TRBDATA_MODULEID       = 0x0700000;
    const uint32_t SHIFT_TRBDATA_MODULEID       = 20;
    const uint32_t MASK_EVNTCNT  = 0xFFFFFF;
    const uint32_t MASK_CRC      = 0xFFFFFF;
    const uint32_t END_OF_DAQ    = 0x7000EEE; // magic word
    
    const unsigned int usefulBitsModuleData = 32 ; // How many bits are used per word? All MASK / TAG constants rely on this alignment
    // MASKS for module data
    
    const uint32_t MASK_MODULE_HEADER = 0xFC002000;
    const uint32_t TAG_MODULE_HEADER  = 0xE8002000;
    const uint32_t MASK_MODULE_TRAILER= 0xFFFF0000;
    const uint32_t TAG_MODULE_TRAILER = 0x80000000;
    const uint32_t MASK_MODULE_ERROR  = 0xE0200000;
    const uint32_t TAG_MODULE_ERROR   = 0x00200000;
    const uint32_t MASK_MODULE_CONFIG = 0xE1C02010;
    const uint32_t TAG_MODULE_CONFIG  = 0x1C02010;
    const uint32_t MASK_MODULE_DATA   = 0xC0040000;
    const uint32_t TAG_MODULE_DATA    = 0x40040000;
    const uint32_t MASK_MODULE_NODATA = 0xE0000000;
    const uint32_t TAG_MODULE_NODATA  = 0x20000000;
    
    // access data modules with bit shift & mask
    const uint32_t RSHIFT_MODULE_BCID = 14;
    const uint32_t MASK_MODULE_BCID   = 0xff;
    const uint32_t RSHIFT_MODULE_L1ID = 22;
    const uint32_t MASK_MODULE_L1ID   = 0xf;
    
    const uint32_t RSHIFT_CHIPADD_CONF = 25;
    const uint32_t MASK_CHIPADD_CONF   = 0xF;
    const uint32_t RSHIFT_CONF1        = 14;
    const uint32_t RSHIFT_CONF2        = 5;
    const uint32_t MASK_CONF           = 0xFF;
    const uint32_t RSHIFT_CHIPADD_ERR  = 25;
    const uint32_t MASK_CHIPADD_ERR    = 0xF;
    const uint32_t RSHIFT_ERR          = 22;
    const uint32_t MASK_ERR            = 0x7;
    const uint32_t RSHIFT_CHIPADD_DATA = 26;
    const uint32_t MASK_CHIPADD_DATA   = 0xF;
    const uint32_t RSHIFT_CHANNEL_DATA = 19;
    const uint32_t MASK_CHANNEL_DATA   = 0x7F;
#pragma endregion constants
  
  class SCTEvent {
  public:
    SCTEvent (unsigned int moduleID, unsigned int l1id, unsigned int bcid);
    ~SCTEvent();
    
    void AddHeader(unsigned int l1id, unsigned int bcid);
    void AddHit (unsigned int chip, unsigned int strip, unsigned int pattern);
    void AddError (unsigned int chip, unsigned int err);
    void AddUnknownChip (unsigned int chip) {m_UnkownChips.push_back(chip);}
    
    unsigned int GetNHits();
    unsigned int GetNHits(int chip);
    std::vector < std::vector < std::pair<uint8_t, uint8_t> > > GetHits() {return m_Hits;}
    std::vector < std::pair<uint8_t, uint8_t> >                 GetHits(int chip);
    std::vector < std::vector < uint8_t > >                     GetErrors() {return m_Errors;}
    std::vector < uint8_t >                                     GetErrors(int chip);
    std::vector < uint8_t >                                     GetUnknownChips() {return m_UnkownChips;}
    
    bool HasError() {return m_hasError;}
    bool IsComplete() {return m_complete;}
    void SetComplete() {m_complete = true;}
    bool MissingData() {return m_missingData;}
    void SetMissingData() {m_missingData = true;}
    bool BCIDMismatch() {return m_bcidMismatch;}
    void SetBCIDMismatch() {m_bcidMismatch = true;}
    unsigned short GetL1ID() {return m_l1id;}
    unsigned short GetBCID() {return m_bcid;}
    
  private:
    std::vector < std::vector < std::pair<uint8_t, uint8_t> > > m_Hits; // chips[12][nHits] , hit = pair {Strip Nr, Hit pattern}
    std::vector < std::vector < uint8_t > > m_Errors; // chips[12][error]
    std::vector < uint8_t > m_UnkownChips; // chipIDs that were not expected
    unsigned short m_moduleID;
    unsigned short m_bcid;
    unsigned short m_l1id;
   
    bool m_complete; // sepcifies if data from all chips (i.e. LED and LEDX lines is inserted
    bool m_missingData; // sepcifies if data from all chips (i.e. LED and LEDX lines is inserted
    bool m_bcidMismatch; // bcid mismatch between led and ledX data streams
    bool m_hasError; // bcid mismatch between led and ledX data streams
    std::map<unsigned int, unsigned int> m_chipIDMap; // maps chipID to vector index
  };

  
  TrackerDataFragment( const uint32_t *data, size_t size ) {
    m_size = size;
    m_debug = false;
    event.m_event_id = 0xffffff;
    event.m_bc_id = 0xffff;

    // now to fill data members from data - can refer to TRBEvent in gpiodrivers.
    const uint32_t errorMask   = 0x0000000F; //  4 bits
    const uint32_t bcidMask    = 0x00000FFF; // 12 bits
    const uint32_t payloadMask = 0x00FFFFFF; // 24 bits

    for (size_t i=0; i<size/4;i++ )
    {
       int frameType = (data[i] & 0x3<<30)>>30;//(d & 0b11<<30)>>30;
       int frameCounter=(data[i] & 0x7<<27)>>27;
       int moduleOrInfo=(data[i] & 0x7<<24)>>24;
       int modNer=0; //mod ID in error message
       int errId=(data[i]&0xF);
       
      // std::cout<<frameType<<" | "<<frameCounter<<std::endl;
       if (frameType==0 and moduleOrInfo==0){event.m_event_id=data[i]&payloadMask;}
       if (frameType==1)
       { 
         switch(moduleOrInfo)
         {
           case 0:event.m_bc_id=data[i]&bcidMask; break;
           case 1:        
                  std::cout<<"TRB ERROR: "<<errId<<std::endl; 
                  event.m_trb_error_id=errId;
                  break;
           case 2:
           case 3:
                  modNer=(data[i]&0x7<<24)>>24;
                  event.m_module_error_ids.push_back((frameType%2)<<7 | (modNer) << 4 | errId);
                  std::cout<<"LED(x) Module error: Module "<<modNer<<" ErrID: "<<errId<<std::endl; break;

         }

       }
       
       if (frameType == 2 || frameType == 3)
	{
	     std::pair<uint8_t, uint8_t> key { moduleOrInfo , (frameType == 2 ? 0 : 1) };
	     event.m_modDB[key].push_back(data[i] & payloadMask);
	}       
    }
  
}
    
  bool valid() const {
    if (m_size<sizeof(event.m_event_id) ) return false; //example. Eventually to check dimensions of data, check for error ids.
  
    return true;
  }

  public:
    // getters
    uint32_t event_id() const { return event.m_event_id; }
    uint32_t bc_id() const { return event.m_bc_id; }
    size_t size() const { return m_size; }
    uint8_t trb_error_id() const { return event.m_trb_error_id;}
    std::vector<uint8_t>  module_error_id() const { return event.m_module_error_ids;}
    std::map< std::pair<uint8_t, uint8_t>,std::vector<uint32_t> >  module_modDB() const {return  event.m_modDB;}
    //setters
    void set_debug_on( bool debug = true ) { m_debug = debug; }

    void DecodeModuleData(std::map< std::pair<uint8_t, uint8_t>, std::vector<uint32_t> > dataMap){
      for(int module=0;module<8;module++){
        for(int LED=0;LED<2;LED++){
          SCTEvent *sctEvent;
          //TrackerDataFragment *trackerFragment;//TRBEvent *trbEvent;

          bool praeambleFound = false;
          std::pair<uint8_t, uint8_t> ModuleSide { module, LED };
          Bitstream bitstream(dataMap[ModuleSide]); //something with moduleData[module] in ()
          int removedBits = 0;

          auto time_start = std::chrono::high_resolution_clock::now();
          auto time_end = std::chrono::high_resolution_clock::now();
          long int eventCount = 0;
          while (bitstream.BitsAvailable()){
            // std::cout << "Data word = "<<std::hex << bitstream.GetWord32() <<std::endl;
            if ((bitstream.GetWord32() & MASK_MODULE_HEADER) == TAG_MODULE_HEADER){
              eventCount++;
              if (eventCount %5000 == 0 ){ 
                time_end = std::chrono::high_resolution_clock::now();
                auto duration = std::chrono::duration_cast<std::chrono::microseconds>(time_end-time_start);
                std::cout << "Decodeding module data for evnt: "<<eventCount<< " rate = "<<5.0e6/duration.count()<<" kHz"<<std::endl;
                time_start = std::chrono::high_resolution_clock::now();
              }
              unsigned int l1id = ((bitstream.GetWord32() >> RSHIFT_MODULE_L1ID)&MASK_MODULE_L1ID);
              unsigned int bcid = ((bitstream.GetWord32() >> RSHIFT_MODULE_BCID)&MASK_MODULE_BCID);

              //if (m_PrintEventInformation > 1) std::cout << "Module Header: L1D = "<<std::dec<< l1id <<" BCID = "<< bcid << std::endl;
              //if (m_PrintEventInformation > 0) std::cout << "     removed bits bfore finding Module Header = "<<removedBits<<std::endl;

              if (LED==0){
                // process first half of module data (led / ledx line)
                //if (m_Events.size() == 0){} // first event
                //trbEvent = new TRBEvent(l1id, bcid);
                sctEvent = new SCTEvent(module, l1id, bcid);
                //trbEvent->AddModule(module, sctEvent);
                //m_Events.push_back(trbEvent);
              }
              removedBits = 0;
              bitstream.RemoveBits(19);
              praeambleFound = true;
              continue;
            }
            if (!praeambleFound){
            bitstream.RemoveBits(1);
            removedBits++;
            continue;
            }

            if ((bitstream.GetWord32() & MASK_MODULE_ERROR) == TAG_MODULE_ERROR && praeambleFound){
              unsigned int chip = ((bitstream.GetWord32() >> RSHIFT_CHIPADD_ERR)&MASK_CHIPADD_ERR);
              unsigned int err = ((bitstream.GetWord32() >> RSHIFT_ERR)&MASK_ERR);
              //if (m_PrintEventInformation > 0) std::cout << "Module Data: ERROR code 0x"<<std::hex<< err << " for chip "<<std::dec<< chip <<std::endl;
              sctEvent->AddError(chip, err);
              bitstream.RemoveBits(11);
              continue;
            }
            if ((bitstream.GetWord32() & MASK_MODULE_CONFIG) == TAG_MODULE_CONFIG && praeambleFound){
              bitstream.RemoveBits(28);
              continue;
            }
            if ((bitstream.GetWord32() & MASK_MODULE_DATA) == TAG_MODULE_DATA && praeambleFound){
              unsigned int chip = ((bitstream.GetWord32() >> RSHIFT_CHIPADD_DATA)&MASK_CHIPADD_DATA);
              unsigned int channel = ((bitstream.GetWord32() >> RSHIFT_CHANNEL_DATA)&MASK_CHANNEL_DATA);
              bitstream.RemoveBits(13); // after that we expect n-times <1><xxx> => check MSB to be 1
              while ( ((bitstream.GetWord32() & 0x80000000) == 0x80000000) ){
                // data packet
                // !!! Trailer looks the same in this definition! => Always check if a trailer is found
                if ((bitstream.GetWord32() & MASK_MODULE_TRAILER) == TAG_MODULE_TRAILER){
                //if (m_PrintEventInformation > 1) std::cout << "Module Trailer "<< std::endl;
                bitstream.RemoveBits(16);
                praeambleFound = false;
                
                continue;
                }
                unsigned int hit = (bitstream.GetWord32() >> 28) & 0x7;
                sctEvent->AddHit(chip, channel, hit);
                //if (m_PrintEventInformation > 4) std::cout << "  Hit pattern = "<<hit<<std::endl;
                bitstream.RemoveBits(4);
              }
              continue;
            }
            
            if ((bitstream.GetWord32() & MASK_MODULE_NODATA) == TAG_MODULE_NODATA && praeambleFound) {
              //if (m_PrintEventInformation > 4) std::cout << "  No Hit packet"<<std::endl;
              bitstream.RemoveBits(3);
              continue;
            }

                // data is only valid after a praeamble (aka header) was found. Otherwise praeamble might be mistaken as an error code
            praeambleFound = false;
            // std::cout << "WARNING: unable to decode bitstream. Removing 1 bit until alignment is found again."<<std::endl;
            bitstream.RemoveBits (1);          
          }

        }
      }
    
  
  int removedBits = 0;
  auto time_start = std::chrono::high_resolution_clock::now();
  auto time_end = std::chrono::high_resolution_clock::now();
  long int eventCount = 0;

  

    return;
  }
  SCTEvent* GetModule(unsigned int moduleID){}
  const SCTEvent& GetModule(uint32_t moduleID) const;
  Bitstream* GetModuleBitstream(unsigned int module, bool led);
  //std::vector <TrackerDataFragment *> GetEvents() {return m_Events;}


  private:
    struct TRBEvent {
      uint32_t m_event_id;
      uint32_t m_bc_id;
      uint8_t m_trb_error_id;
      std::vector< uint8_t > m_module_error_ids;
      std::map< std::pair<uint8_t, uint8_t>, std::vector<uint32_t> > m_modDB;
      std::vector < SCTEvent > m_hits_per_module; // SCTEvent to be implemented in 2nd step.
    }  event;
    size_t m_size;
    bool m_debug;
    void AddModule(unsigned int moduleID, SCTEvent *event){}
  
    int m_PrintEventInformation;
    
    //std::vector <TRBEvent *> m_Events;
    //std::vector <std::vector <TRBEvent *> > m_EventsPerScanStep;
    
    std::vector<uint32_t> m_data;
    std::vector<char> m_dataBytes;
    std::vector< std::vector<uint32_t> > m_moduleData_led; /// Vector holding 8 vectors of 32bit words = 8 modules
    std::vector< std::vector<uint32_t> > m_moduleData_ledx; /// Vector holding 8 vectors of 32bit words = 8 modules
    bool m_headerOK;
    bool m_trailerOK;
    int m_eventCnt;
    int m_eventCntEOD;
};

void AddHit (unsigned int chip, unsigned int strip, unsigned int pattern, int chipID)
//what is m_chipIDMap
//where is m_Hits
{
  std::vector < std::vector < std::pair<uint8_t, uint8_t> > > m_Hits;
  chip |= 0x20; // adding 2 MSB for chip address. All chips are served by "primary fiber".
  /*auto it = m_chipIDMap.find(chip); //fix this
  if (it == m_chipIDMap.end()) { //fix this when i know what chipIDmap is
    if (false){
      std::cout << "ERROR: AddHit(): passed chipID is not known! chipID = 0x"<<std::hex<<chip<<std::endl;
      std::cout << "Known IDs: "<<std::endl;
      for (auto it : m_chipIDMap){
        std::cout << " ChipID = 0x"<<std::hex<<it.first<<" Index = "<<std::dec<<it.second<<std::endl;
        m_Hits.back().push_back(std::make_pair(chip, strip));
      }
    }
    return;
  }
  m_Hits[it->second].push_back(std::make_pair(strip, pattern)); */
  
}

/** \brief Support class providing a contineous bitstream, used to analyse SCT module data.
The input vector is expected to contain the module data in the 24 LSB of the 32 bit words,
as received from the tracker readout board. Bitstream data is stringed together and available in
junks of 32-bits using Get32BitWord(). RemoveBits(n) will remvove the n MSB from the bitstream.
Next call to Get32BitWord() will have the reamining bitstream aligned properly at the MSB of the
word.
*/


inline std::ostream &operator<<(std::ostream &out, const TrackerDataFragment &event) {
  try {
    out
    <<std::setw(11)<<" event_id: "<<std::setfill(' ')<<std::setw(32)<<event.event_id()<<std::setfill(' ')<<std::endl
    <<std::setw(11)<<" bc_id: "<<std::setfill(' ')<<std::setw(32)<<event.bc_id()<<std::setfill(' ')<<std::endl
    <<std::endl;
  } catch ( TrackerDataException& e ) {
    out<<e.what()<<std::endl;
    out<<"Corrupted data for Tracker data event "<<event.event_id()<<", bcid "<<event.bc_id()<<std::endl;
    out<<"Fragment size is "<<event.size()<<" bytes total"<<std::endl;
  }

 return out;
}

